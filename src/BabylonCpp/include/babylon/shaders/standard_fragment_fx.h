#ifndef BABYLON_SHADERS_STANDARD_FRAGMENT_FX_H
#define BABYLON_SHADERS_STANDARD_FRAGMENT_FX_H

namespace BABYLON {

extern const char* standardPixelShader;

const char* standardPixelShader
  = "uniform sampler2D textureSampler;\n"
    "varying vec2 vUV;\n"
    "\n"
    "#if defined(PASS_POST_PROCESS)\n"
    "void main(void)\n"
    "{\n"
    "  vec4 color = texture2D(textureSampler, vUV);\n"
    "  gl_FragColor = color;\n"
    "}\n"
    "#endif\n"
    "\n"
    "#if defined(DOWN_SAMPLE_X4)\n"
    "uniform vec2 dsOffsets[16];\n"
    "\n"
    "void main(void)\n"
    "{\n"
    "  vec4 average = vec4(0.0, 0.0, 0.0, 0.0);\n"
    "\n"
    "  average = texture2D(textureSampler, vUV + dsOffsets[0]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[1]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[2]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[3]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[4]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[5]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[6]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[7]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[8]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[9]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[10]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[11]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[12]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[13]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[14]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[15]);\n"
    "\n"
    "  average /= 16.0;\n"
    "\n"
    "  gl_FragColor = average;\n"
    "}\n"
    "#endif\n"
    "\n"
    "#if defined(BRIGHT_PASS)\n"
    "uniform vec2 dsOffsets[4];\n"
    "uniform float brightThreshold;\n"
    "\n"
    "void main(void)\n"
    "{\n"
    "  vec4 average = vec4(0.0, 0.0, 0.0, 0.0);\n"
    "\n"
    "  average = texture2D(textureSampler, vUV + vec2(dsOffsets[0].x, dsOffsets[0].y));\n"
    "  average += texture2D(textureSampler, vUV + vec2(dsOffsets[1].x, dsOffsets[1].y));\n"
    "  average += texture2D(textureSampler, vUV + vec2(dsOffsets[2].x, dsOffsets[2].y));\n"
    "  average += texture2D(textureSampler, vUV + vec2(dsOffsets[3].x, dsOffsets[3].y));\n"
    "\n"
    "  average *= 0.25;\n"
    "\n"
    "  float luminance = length(average.rgb);\n"
    "\n"
    "  if (luminance < brightThreshold) {\n"
    "  average = vec4(0.0, 0.0, 0.0, 1.0);\n"
    "  }\n"
    "\n"
    "  gl_FragColor = average;\n"
    "}\n"
    "#endif\n"
    "\n"
    "#if defined(GAUSSIAN_BLUR_H) || defined(GAUSSIAN_BLUR_V)\n"
    "uniform float blurOffsets[9];\n"
    "uniform float blurWeights[9];\n"
    "uniform float blurWidth;\n"
    "\n"
    "void main(void)\n"
    "{\n"
    "  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n"
    "\n"
    "  for (int i = 0; i < 9; i++) {\n"
    "#ifdef GAUSSIAN_BLUR_H\n"
    "  color += (texture2D(textureSampler, vUV + vec2(blurOffsets[i] * blurWidth, 0.0)) * blurWeights[i]);\n"
    "  color += (texture2D(textureSampler, vUV - vec2(blurOffsets[i] * blurWidth, 0.0)) * blurWeights[i]);\n"
    "#else\n"
    "  color += (texture2D(textureSampler, vUV + vec2(0.0, blurOffsets[i] * blurWidth)) * blurWeights[i]);\n"
    "  color += (texture2D(textureSampler, vUV - vec2(0.0, blurOffsets[i] * blurWidth)) * blurWeights[i]);\n"
    "#endif\n"
    "  }\n"
    "\n"
    "  color.a = 1.0;\n"
    "  gl_FragColor = color;\n"
    "}\n"
    "#endif\n"
    "\n"
    "#if defined(TEXTURE_ADDER)\n"
    "uniform sampler2D otherSampler;\n"
    "uniform sampler2D lensSampler;\n"
    "\n"
    "uniform float exposure;\n"
    "\n"
    "void main(void)\n"
    "{\n"
    "  vec3 colour = texture2D(textureSampler, vUV).rgb;\n"
    "\n"
    "  colour *= exposure;\n"
    "\n"
    "  vec3 X = max(vec3(0.0, 0.0, 0.0), colour - 0.004);\n"
    "  vec3 retColor = (X * (6.2 * X + 0.5)) / (X * (6.2 * X + 1.7) + 0.06);\n"
    "\n"
    "  colour = retColor * retColor;\n"
    "  colour += colour * texture2D(lensSampler, vUV).rgb;\n"
    "\n"
    "  vec4 finalColor = vec4(colour.rgb, 1.0) + texture2D(otherSampler, vUV);\n"
    "\n"
    "  gl_FragColor = finalColor;\n"
    "}\n"
    "#endif\n"
    "\n"
    "#if defined(LENS_FLARE)\n"
    "#define GHOSTS 3\n"
    "\n"
    "uniform sampler2D lensColorSampler;\n"
    "\n"
    "uniform float strength;\n"
    "uniform float ghostDispersal;\n"
    "uniform float haloWidth;\n"
    "\n"
    "uniform vec2 resolution;\n"
    "uniform float distortionStrength;\n"
    "\n"
    "float hash(vec2 p)\n"
    "{\n"
    "  float h = dot(p, vec2(127.1, 311.7));\n"
    "  return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n"
    "}\n"
    "\n"
    "float noise(in vec2 p)\n"
    "{\n"
    "  vec2 i = floor(p);\n"
    "  vec2 f = fract(p);\n"
    "  vec2 u = f*f*(3.0 - 2.0*f);\n"
    "\n"
    "  return mix(mix(hash(i + vec2(0.0, 0.0)),\n"
    "  hash(i + vec2(1.0, 0.0)), u.x),\n"
    "  mix(hash(i + vec2(0.0, 1.0)),\n"
    "  hash(i + vec2(1.0, 1.0)), u.x), u.y);\n"
    "}\n"
    "\n"
    "float fbm(vec2 p)\n"
    "{\n"
    "  float f = 0.0;\n"
    "  f += 0.5000 * noise(p); p *= 2.02;\n"
    "  f += 0.2500 * noise(p); p *= 2.03;\n"
    "  f += 0.1250 * noise(p); p *= 2.01;\n"
    "  f += 0.0625 * noise(p); p *= 2.04;\n"
    "  f /= 0.9375;\n"
    "  return f;\n"
    "}\n"
    "\n"
    "vec3 pattern(vec2 uv)\n"
    "{\n"
    "  vec2 p = -1.0 + 2.0 * uv;\n"
    "  float p2 = dot(p, p);\n"
    "  float f = fbm(vec2(15.0*p2)) / 2.0;\n"
    "  float r = 0.2 + 0.6 * sin(12.5*length(uv - vec2(0.5)));\n"
    "  float g = 0.2 + 0.6 * sin(20.5*length(uv - vec2(0.5)));\n"
    "  float b = 0.2 + 0.6 * sin(17.2*length(uv - vec2(0.5)));\n"
    "  return (1.0 - f) * vec3(r, g, b);\n"
    "}\n"
    "\n"
    "float luminance(vec3 color)\n"
    "{\n"
    "  return dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));\n"
    "}\n"
    "\n"
    "vec4 textureDistorted(sampler2D tex, vec2 texcoord, vec2 direction, vec3 distortion)\n"
    "{\n"
    "  return vec4(\n"
    "  texture2D(tex, texcoord + direction * distortion.r).r,\n"
    "  texture2D(tex, texcoord + direction * distortion.g).g,\n"
    "  texture2D(tex, texcoord + direction * distortion.b).b,\n"
    "  1.0\n"
    "  );\n"
    "}\n"
    "\n"
    "void main(void)\n"
    "{\n"
    "  vec2 uv = -vUV + vec2(1.0);\n"
    "  vec2 ghostDir = (vec2(0.5) - uv) * ghostDispersal;\n"
    "\n"
    "  vec2 texelSize = 1.0 / resolution;\n"
    "  vec3 distortion = vec3(-texelSize.x * distortionStrength, 0.0, texelSize.x * distortionStrength);\n"
    "\n"
    "  vec4 result = vec4(0.0);\n"
    "  float ghostIndice = 1.0;\n"
    "\n"
    "  for (int i = 0; i < GHOSTS; ++i)\n"
    "  {\n"
    "  vec2 offset = fract(uv + ghostDir * ghostIndice);\n"
    "  float weight = length(vec2(0.5) - offset) / length(vec2(0.5));\n"
    "  weight = pow(1.0 - weight, 10.0);\n"
    "\n"
    "  result += textureDistorted(textureSampler, offset, normalize(ghostDir), distortion) * weight * strength;\n"
    "\n"
    "  ghostIndice += 1.0;\n"
    "  }\n"
    "\n"
    "  vec2 haloVec = normalize(ghostDir) * haloWidth;\n"
    "\n"
    "  float weight = length(vec2(0.5) - fract(uv + haloVec)) / length(vec2(0.5));\n"
    "  weight = pow(1.0 - weight, 10.0);\n"
    "\n"
    "  result += textureDistorted(textureSampler, fract(uv + haloVec), normalize(ghostDir), distortion) * weight * strength;\n"
    "\n"
    "  result *= texture2D(lensColorSampler, vec2(length(vec2(0.5) - uv) / length(vec2(0.5))));\n"
    "\n"
    "  gl_FragColor = result;\n"
    "}\n"
    "#endif\n"
    "\n"
    "#if defined(LENS_FLARE_COMPOSE)\n"
    "uniform sampler2D otherSampler;\n"
    "uniform sampler2D lensDirtSampler;\n"
    "uniform sampler2D lensStarSampler;\n"
    "\n"
    "uniform mat4 lensStarMatrix;\n"
    "\n"
    "void main(void)\n"
    "{\n"
    "  vec2 lensFlareCoords = (lensStarMatrix * vec4(vUV, 1.0, 1.0)).xy;\n"
    "\n"
    "  vec4 lensMod = texture2D(lensDirtSampler, vUV);\n"
    "  lensMod += texture2D(lensStarSampler, vUV/*lensFlareCoords*/);\n"
    "\n"
    "  vec4 result = texture2D(textureSampler, vUV) * lensMod;\n"
    "\n"
    "  gl_FragColor = texture2D(otherSampler, vUV) + result;\n"
    "}\n"
    "#endif\n"
    "\n"
    "#if defined(DEPTH_OF_FIELD)\n"
    "uniform sampler2D otherSampler;\n"
    "uniform sampler2D depthSampler;\n"
    "\n"
    "uniform float distance;\n"
    "\n"
    "void main(void)\n"
    "{\n"
    "  vec4 sharp = texture2D(otherSampler, vUV);\n"
    "  vec4 blur = texture2D(textureSampler, vUV);\n"
    "  float dist = clamp(texture2D(depthSampler, vUV).r * distance, 0.0, 1.0);\n"
    "  float factor = 0.0;\n"
    "\n"
    "  if (dist < 0.05)\n"
    "  factor = 1.0;\n"
    "  else if (dist < 0.1)\n"
    "  factor = 20.0 * (0.1 - dist);\n"
    "  else if (dist < 0.5)\n"
    "  factor = 0.0;\n"
    "  else\n"
    "  factor = 2.0 * (dist - 0.5);\n"
    "\n"
    "  factor = clamp(factor, 0.0, 0.90);\n"
    "  gl_FragColor = mix(sharp, blur, factor);\n"
    "}\n"
    "\n"
    "#endif\n";

} // end of namespace BABYLON

#endif // end of BABYLON_SHADERS_STANDARD_FRAGMENT_FX_H
