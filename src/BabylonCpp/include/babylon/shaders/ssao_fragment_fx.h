#ifndef BABYLON_SHADERS_SSAO_FRAGMENT_FX_H
#define BABYLON_SHADERS_SSAO_FRAGMENT_FX_H

namespace BABYLON {

extern const char* ssaoPixelShader;

const char* ssaoPixelShader
  = "// SSAO Shader\n"
    "uniform sampler2D textureSampler;\n"
    "\n"
    "varying vec2 vUV;\n"
    "\n"
    "#ifdef SSAO\n"
    "uniform sampler2D randomSampler;\n"
    "\n"
    "uniform float randTextureTiles;\n"
    "uniform float samplesFactor;\n"
    "uniform vec3 sampleSphere[SAMPLES];\n"
    "\n"
    "uniform float totalStrength;\n"
    "uniform float radius;\n"
    "uniform float area;\n"
    "uniform float fallOff;\n"
    "uniform float base;\n"
    "\n"
    "vec3 normalFromDepth(float depth, vec2 coords)\n"
    "{\n"
    "  vec2 offset1 = vec2(0.0, radius);\n"
    "  vec2 offset2 = vec2(radius, 0.0);\n"
    "\n"
    "  float depth1 = texture2D(textureSampler, coords + offset1).r;\n"
    "  float depth2 = texture2D(textureSampler, coords + offset2).r;\n"
    "\n"
    "  vec3 p1 = vec3(offset1, depth1 - depth);\n"
    "  vec3 p2 = vec3(offset2, depth2 - depth);\n"
    "\n"
    "  vec3 normal = cross(p1, p2);\n"
    "  normal.z = -normal.z;\n"
    "\n"
    "  return normalize(normal);\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "  vec3 random = normalize(texture2D(randomSampler, vUV * randTextureTiles).rgb);\n"
    "  float depth = texture2D(textureSampler, vUV).r;\n"
    "  vec3 position = vec3(vUV, depth);\n"
    "  vec3 normal = normalFromDepth(depth, vUV);\n"
    "  float radiusDepth = radius / depth;\n"
    "  float occlusion = 0.0;\n"
    "\n"
    "  vec3 ray;\n"
    "  vec3 hemiRay;\n"
    "  float occlusionDepth;\n"
    "  float difference;\n"
    "\n"
    "  for (int i = 0; i < SAMPLES; i++)\n"
    "  {\n"
    "  ray = radiusDepth * reflect(sampleSphere[i], random);\n"
    "  hemiRay = position + sign(dot(ray, normal)) * ray;\n"
    "\n"
    "  occlusionDepth = texture2D(textureSampler, clamp(hemiRay.xy, vec2(0.001, 0.001), vec2(0.999, 0.999))).r;\n"
    "  difference = depth - occlusionDepth;\n"
    "\n"
    "  occlusion += step(fallOff, difference) * (1.0 - smoothstep(fallOff, area, difference));\n"
    "  }\n"
    "\n"
    "  float ao = 1.0 - totalStrength * occlusion * samplesFactor;\n"
    "  float result = clamp(ao + base, 0.0, 1.0);\n"
    "\n"
    "  gl_FragColor.r = result;\n"
    "  gl_FragColor.g = result;\n"
    "  gl_FragColor.b = result;\n"
    "  gl_FragColor.a = 1.0;\n"
    "}\n"
    "#endif\n"
    "\n"
    "#ifdef BILATERAL_BLUR\n"
    "uniform sampler2D depthSampler;\n"
    "uniform float outSize;\n"
    "uniform float samplerOffsets[SAMPLES];\n"
    "\n"
    "void main()\n"
    "{\n"
    "\n"
    "  float texelsize = 1.0 / outSize;\n"
    "  float compareDepth = texture2D(depthSampler, vUV).r;\n"
    "  float result = 0.0;\n"
    "  float weightSum = 0.0;\n"
    "\n"
    "  for (int i = 0; i < SAMPLES; ++i)\n"
    "  {\n"
    "  #ifdef BILATERAL_BLUR_H\n"
    "  vec2 sampleOffset = vec2(texelsize * samplerOffsets[i], 0.0);\n"
    "  #else\n"
    "  vec2 sampleOffset = vec2(0.0, texelsize * samplerOffsets[i]);\n"
    "  #endif\n"
    "  vec2 samplePos = vUV + sampleOffset;\n"
    "\n"
    "  float sampleDepth = texture2D(depthSampler, samplePos).r;\n"
    "  float weight = (1.0 / (0.0001 + abs(compareDepth - sampleDepth)));\n"
    "\n"
    "  result += texture2D(textureSampler, samplePos).r * weight;\n"
    "  weightSum += weight;\n"
    "  }\n"
    "\n"
    "  result /= weightSum;\n"
    "\n"
    "  gl_FragColor.rgb = vec3(result);\n"
    "  gl_FragColor.a = 1.0;\n"
    "}\n"
    "#endif\n";

} // end of namespace BABYLON

#endif // end of BABYLON_SHADERS_SSAO_FRAGMENT_FX_H
