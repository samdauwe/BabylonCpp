#ifndef BABYLON_SHADERS_SHADERS_INCLUDE_BUMP_FRAGMENT_FUNCTIONS_FX_H
#define BABYLON_SHADERS_SHADERS_INCLUDE_BUMP_FRAGMENT_FUNCTIONS_FX_H

namespace BABYLON {

extern const char* bumpFragmentFunctions;

const char* bumpFragmentFunctions
  = "#ifdef BUMP\n"
    "  varying vec2 vBumpUV;\n"
    "  uniform vec3 vBumpInfos;\n"
    "  uniform sampler2D bumpSampler;\n"
    "\n"
    "  // Thanks to http://www.thetenthplanet.de/archives/1180\n"
    "  mat3 cotangent_frame(vec3 normal, vec3 p, vec2 uv)\n"
    "  {\n"
    "  // get edge vectors of the pixel triangle\n"
    "  vec3 dp1 = dFdx(p);\n"
    "  vec3 dp2 = dFdy(p);\n"
    "  vec2 duv1 = dFdx(uv);\n"
    "  vec2 duv2 = dFdy(uv);\n"
    "\n"
    "  // solve the linear system\n"
    "  vec3 dp2perp = cross(dp2, normal);\n"
    "  vec3 dp1perp = cross(normal, dp1);\n"
    "  vec3 tangent = dp2perp * duv1.x + dp1perp * duv2.x;\n"
    "  vec3 binormal = dp2perp * duv1.y + dp1perp * duv2.y;\n"
    "\n"
    "  // construct a scale-invariant frame \n"
    "  float invmax = inversesqrt(max(dot(tangent, tangent), dot(binormal, binormal)));\n"
    "  return mat3(tangent * invmax, binormal * invmax, normal);\n"
    "  }\n"
    "\n"
    "  vec3 perturbNormal(vec3 viewDir, mat3 cotangentFrame, vec2 uv)\n"
    "  {\n"
    "  vec3 map = texture2D(bumpSampler, uv).xyz;\n"
    "\n"
    "  #ifdef INVERTNORMALMAPX\n"
    "  map.x = 1.0 - map.x;\n"
    "  #endif\n"
    "  #ifdef INVERTNORMALMAPY\n"
    "  map.y = 1.0 - map.y;\n"
    "  #endif\n"
    "\n"
    "  map = map * 255. / 127. - 128. / 127.;\n"
    "  return normalize(cotangentFrame * map);\n"
    "  }\n"
    "\n"
    "  #ifdef PARALLAX\n"
    "  const float minSamples = 4.;\n"
    "  const float maxSamples = 15.;\n"
    "  const int iMaxSamples = 15;\n"
    "\n"
    "  // http://www.gamedev.net/page/resources/_/technical/graphics-programming-and-theory/a-closer-look-at-parallax-occlusion-mapping-r3262\n"
    "  vec2 parallaxOcclusion(vec3 vViewDirCoT, vec3 vNormalCoT, vec2 texCoord, float parallaxScale) {\n"
    "\n"
    "  float parallaxLimit = length(vViewDirCoT.xy) / vViewDirCoT.z;\n"
    "  parallaxLimit *= parallaxScale;\n"
    "  vec2 vOffsetDir = normalize(vViewDirCoT.xy);\n"
    "  vec2 vMaxOffset = vOffsetDir * parallaxLimit;\n"
    "  float numSamples = maxSamples + (dot(vViewDirCoT, vNormalCoT) * (minSamples - maxSamples));\n"
    "  float stepSize = 1.0 / numSamples;\n"
    "\n"
    "  // Initialize the starting view ray height and the texture offsets.\n"
    "  float currRayHeight = 1.0;\n"
    "  vec2 vCurrOffset = vec2(0, 0);\n"
    "  vec2 vLastOffset = vec2(0, 0);\n"
    "\n"
    "  float lastSampledHeight = 1.0;\n"
    "  float currSampledHeight = 1.0;\n"
    "\n"
    "  for (int i = 0; i < iMaxSamples; i++)\n"
    "  {\n"
    "  currSampledHeight = texture2D(bumpSampler, vBumpUV + vCurrOffset).w;\n"
    "\n"
    "  // Test if the view ray has intersected the surface.\n"
    "  if (currSampledHeight > currRayHeight)\n"
    "  {\n"
    "  float delta1 = currSampledHeight - currRayHeight;\n"
    "  float delta2 = (currRayHeight + stepSize) - lastSampledHeight;\n"
    "  float ratio = delta1 / (delta1 + delta2);\n"
    "  vCurrOffset = (ratio)* vLastOffset + (1.0 - ratio) * vCurrOffset;\n"
    "\n"
    "  // Force the exit of the loop\n"
    "  break;\n"
    "  }\n"
    "  else\n"
    "  {\n"
    "  currRayHeight -= stepSize;\n"
    "  vLastOffset = vCurrOffset;\n"
    "  vCurrOffset += stepSize * vMaxOffset;\n"
    "\n"
    "  lastSampledHeight = currSampledHeight;\n"
    "  }\n"
    "  }\n"
    "\n"
    "  return vCurrOffset;\n"
    "  }\n"
    "\n"
    "  vec2 parallaxOffset(vec3 viewDir, float heightScale)\n"
    "  {\n"
    "  // calculate amount of offset for Parallax Mapping With Offset Limiting\n"
    "  float height = texture2D(bumpSampler, vBumpUV).w;\n"
    "  vec2 texCoordOffset = heightScale * viewDir.xy * height;\n"
    "  return -texCoordOffset;\n"
    "  }\n"
    "  #endif\n"
    "#endif\n";

} // end of namespace BABYLON

#endif // end of BABYLON_SHADERS_SHADERS_INCLUDE_BUMP_FRAGMENT_FUNCTIONS_FX_H
